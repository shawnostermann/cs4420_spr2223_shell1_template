%{
#include <stdio.h>
#include "calc.h"


/* some internal files generated by bison */
int yylex();
void yyerror(const char *s,...);
void yywarn(const char *s,...);


/* include debugging code, in case we want it */
#define YYDEBUG 1
int debug = 0;


/* structure for an operator chain */
struct opchain {
    int number;
    int operator;
    struct opchain *next;
};


%}


%union	{ /* the types that we use in the tokens */
    int number;
    int operator;
    struct assignment *pass;
    struct opchain *pop;
}



%token EOLN PLUS MINUS TIMES DIVIDE
%token <number> NUMBER  
  
%type <pass> expr 
%type <pop> rhs
%type <operator> oper
  

%% 	/* beginning of the parsing rules	*/
input	: lines
	|
  	;

lines	: oneline EOLN
	| oneline EOLN lines
	;

oneline : expr
		{ doline($1); }
	| error
		/* if we got an error on the line, don't call the C program */
	;

expr	: rhs
	  {
	      struct assignment *pass;
	      struct opchain *pop;

	      pass = (struct assignment *)
		  		MallocZ(sizeof(struct assignment));
	      /* un-build the operator chain */
	      for (pop = $1; pop; pop = pop->next) {
			if (debug) printf("expr: next number (nops:%d) is %d\n", 
				pass->nops, pass->numbers[pass->nops] = pop->number);
			pass->numbers[pass->nops] = pop->number;
			pass->operators[pass->nops] = pop->operator;
			++pass->nops;
	      }
	      $$ = pass;
	  }


/* right hand side of an assignment */
rhs	: NUMBER
    	{
	      $$ = (struct opchain *) MallocZ(sizeof(struct opchain));
		  if (debug) printf("number is %d\n", $1);
	      $$->number = $1;
		}
	| NUMBER oper rhs
		{
	      $$ = (struct opchain *) MallocZ(sizeof(struct opchain));
	      $$->operator = $2;
	      $$->number = $1;
	      $$->next = $3;
		  if (debug) printf("number is %d\n", $1);

	  	}
	;


/* one of the 4 operators we understand */
oper: PLUS		{ $$ = PLUS;}
	| MINUS		{ $$ = MINUS;}
	| TIMES		{ $$ = TIMES;}
	| DIVIDE	{ $$ = DIVIDE;}
	;

%%

void yyerror(const char *s,...)
{
	fprintf(stderr, "parser: Bad syntax (%s)\n", s);
}

#include <stdlib.h>
#include <string.h>
void *
MallocZ (int nbytes)
{
    char *ptr = malloc(nbytes);
    if (ptr == NULL)
	{
	    perror("malloc failed, fatal\n");
	    exit (66);
	}

	// initialize the space to all zeroes
    memset (ptr, '\00', nbytes);

    return (ptr);
}
